<!DOCTYPE html>
<html>
<head>
    <title>üî¨ Causation Explorer - Curiosity Trail System</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0f0;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            color: #0ff;
            border-bottom: 2px solid #0ff;
            padding-bottom: 10px;
        }
        .main-content {
            display: flex;
            gap: 20px;
        }
        .filter-panel {
            width: 250px;
            background: #111;
            border: 1px solid #0ff;
            padding: 15px;
            height: fit-content;
            position: sticky;
            top: 20px;
        }
        .chat-panel-wrapper {
            width: 1200px; /* Triple the width (400px * 3) to match graph right edge */
            max-width: calc(100% - 300px); /* Don't exceed available space */
            margin-left: 30px; /* Offset to align properly with graph area */
            margin-top: -750px; /* Move up to align with bottom of graph */
            position: relative;
            z-index: 100; /* Ensure dropdowns appear above other elements */
        }
        #craChatPanel {
            overflow: visible !important; /* Ensure dropdowns can extend beyond panel */
        }
        #craChatPanel select {
            position: relative;
            z-index: 101; /* Dropdowns should appear above panel */
            cursor: pointer;
        }
        #craChatPanel select option {
            background: #111;
            color: #0f0;
            padding: 5px;
        }
        .filter-section {
            margin-bottom: 20px;
            border-bottom: 1px solid #0aa;
            padding-bottom: 15px;
        }
        .filter-section h4 {
            color: #0ff;
            margin: 0 0 10px 0;
            font-size: 1em;
        }
        .filter-item {
            margin: 5px 0;
        }
        .filter-item label {
            color: #0f0;
            cursor: pointer;
            display: block;
            padding: 3px 0;
        }
        .filter-item input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }
        .filter-item input[type="checkbox"]:checked + span {
            color: #0ff;
            font-weight: bold;
        }
        .search-box {
            margin: 20px 0;
            padding: 10px;
            background: #111;
            border: 1px solid #0ff;
        }
        input[type="text"] {
            width: 70%;
            padding: 8px;
            background: #000;
            color: #0f0;
            border: 1px solid #0ff;
            font-family: 'Courier New', monospace;
        }
        button {
            padding: 8px 15px;
            background: #0ff;
            color: #000;
            border: none;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        button:hover {
            background: #0aa;
        }
        .nav-button {
            padding: 5px 10px;
            margin: 2px;
            background: #111;
            color: #0ff;
            border: 1px solid #0ff;
            cursor: pointer;
            font-size: 0.9em;
        }
        .nav-button:hover {
            background: #0ff;
            color: #000;
        }
        .graph-container {
            flex: 1;
            position: relative;
        }
        .graph-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #111;
            border: 1px solid #0ff;
            padding: 10px;
            z-index: 10;
        }
        .graph-controls-row {
            display: flex;
            gap: 5px;
            margin: 5px 0;
            justify-content: center;
        }
        #graph {
            width: 100%;
            height: 792px; /* Increased from 600px to 792px (added ~192px / 2 inches) */
            border: 1px solid #0ff;
            background: #000;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }
        #graph svg {
            width: 100%;
            height: 100%;
        }
        .node {
            cursor: pointer;
        }
        .node circle {
            fill: #0ff;
            stroke: #0f0;
            stroke-width: 2px;
        }
        .node text {
            fill: #000000;
            stroke: #FFFFFF;
            stroke-width: 2px;
            stroke-linejoin: round;
            paint-order: stroke fill;
            font-size: 10px;
            font-weight: bold;
        }
        .link {
            stroke: #0aa;
            stroke-opacity: 0.6;
            stroke-width: 2px;
        }
        .link:hover {
            stroke: #0ff;
            stroke-width: 3px;
        }
        .info-panel {
            background: #1a1a1a;
            border: 4px solid #FFFF00;
            padding: 20px;
            margin: 25px 0;
            box-shadow: 0 0 25px rgba(255, 255, 0, 0.5), inset 0 0 15px rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            overflow: visible; /* Allow dropdowns to extend beyond panel */
        }
        .info-panel:nth-child(3) {
            border-color: #FF6600;
            box-shadow: 0 0 25px rgba(255, 102, 0, 0.5), inset 0 0 15px rgba(0, 0, 0, 0.6);
        }
        .info-panel:nth-child(4) {
            border-color: #00FF00;
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.5), inset 0 0 15px rgba(0, 0, 0, 0.6);
        }
        .info-panel:nth-child(5) {
            border-color: #0066FF;
            box-shadow: 0 0 25px rgba(0, 102, 255, 0.5), inset 0 0 15px rgba(0, 0, 0, 0.6);
        }
        .info-panel h3 {
            color: #FFFFFF;
            margin-top: 0;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 3px solid currentColor;
            font-size: 1.4em;
            text-shadow: 0 0 10px currentColor;
        }
        .info-panel:nth-child(3) h3 {
            color: #FF6600;
        }
        .info-panel:nth-child(4) h3 {
            color: #00FF00;
        }
        .info-panel:nth-child(5) h3 {
            color: #0066FF;
        }
        .event-item {
            background: #000;
            border: 1px solid #0aa;
            padding: 10px;
            margin: 10px 0;
            cursor: pointer;
        }
        .event-item:hover {
            border-color: #0ff;
            background: #111;
        }
        .causation-trail {
            margin-left: 20px;
            border-left: 2px solid #0aa;
            padding-left: 15px;
        }
        /* Convergence Research Assistant Chat Interface Styles */
        #craChatPanel {
            border-color: #FF00FF;
            box-shadow: 0 0 25px rgba(255, 0, 255, 0.5), inset 0 0 15px rgba(0, 0, 0, 0.6);
        }
        #craChatPanel h3 {
            color: #FF00FF;
        }
        #chatMessages {
            scrollbar-width: thin;
            scrollbar-color: #0ff #000;
        }
        #chatMessages::-webkit-scrollbar {
            width: 8px;
        }
        #chatMessages::-webkit-scrollbar-track {
            background: #000;
        }
        #chatMessages::-webkit-scrollbar-thumb {
            background: #0ff;
            border-radius: 4px;
        }
        .chat-message {
            margin-bottom: 15px;
            padding: 8px;
            border-left: 3px solid #0ff;
            background: #111;
        }
        .chat-message.user {
            border-left-color: #0f0;
        }
        .chat-message.assistant {
            border-left-color: #0ff;
        }
        .chat-message.vision {
            border-left-color: #ff0;
            font-style: italic;
        }
        .chat-message strong {
            color: #0ff;
        }
        /* HIGH CONTRAST INFORMATION DISPLAY - Different elements use different colors */
        .metric {
            color: #ff0;  /* Bright yellow for metrics/labels */
            font-weight: bold;
        }
        .component {
            color: #0ff;  /* Cyan for component names */
            font-weight: bold;
        }
        .event-type {
            color: #f0f;  /* Magenta for event types */
            font-weight: bold;
        }
        .timestamp {
            color: #0f0;  /* Green for timestamps */
        }
        .data-value {
            color: #ffa500;  /* Orange for data values */
        }
        .data-key {
            color: #0ff;  /* Cyan for data keys */
        }
        .depth-indicator {
            color: #ff6600;  /* Orange-red for depth markers */
            font-weight: bold;
        }
        .count-value {
            color: #00ff00;  /* Bright green for numeric counts */
            font-weight: bold;
        }
        .causation-type {
            color: #ff00ff;  /* Magenta for causation types */
            font-style: italic;
        }
        strong {
            color: #fff;  /* White for general emphasis */
        }
        pre {
            background: #0a0a0a;
            border: 1px solid #0aa;
            padding: 8px;
            margin: 5px 0;
            color: #0ff;
            overflow-x: auto;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¨ Causation Explorer - Follow Your Curiosity</h1>
        
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <div class="search-box" style="flex: 1; margin-right: 10px;">
            <input type="text" id="searchInput" placeholder="Search events (e.g., 'collapse', 'modularity', 'VP')">
            <button onclick="searchEvents()">Search</button>
            <button onclick="loadGraph()">Load Full Graph</button>
            </div>
            <div style="background: #111; border: 1px solid #0ff; padding: 10px; text-align: center;">
                <div id="liveStatus" style="color: #0aa;">‚óè Historical Mode</div>
                <label style="color: #0f0; cursor: pointer; font-size: 0.9em;">
                    <input type="checkbox" id="liveModeToggle" onchange="toggleLiveMode()" style="margin-right: 5px;">
                    Live Mode
                </label>
            </div>
        </div>
        
        <div class="main-content">
            <!-- Filter Panel -->
            <div class="filter-panel">
                <h3 style="color: #0ff; margin-top: 0;">Filters</h3>
                
                <div class="filter-section">
                    <h4>Components</h4>
                    <div class="filter-item">
                        <label><input type="checkbox" id="filter-reality_sim" checked onchange="applyFilters()">
                            <span>Reality Simulator</span></label>
                    </div>
                    <div class="filter-item">
                        <label><input type="checkbox" id="filter-explorer" checked onchange="applyFilters()">
                            <span>Explorer</span></label>
                    </div>
                    <div class="filter-item">
                        <label><input type="checkbox" id="filter-djinn_kernel" checked onchange="applyFilters()">
                            <span>Djinn Kernel</span></label>
                    </div>
                    <div class="filter-item">
                        <label><input type="checkbox" id="filter-breath" checked onchange="applyFilters()">
                            <span>Breath</span></label>
                    </div>
                    <div class="filter-item">
                        <label><input type="checkbox" id="filter-system" checked onchange="applyFilters()">
                            <span>System</span></label>
                    </div>
                </div>
                
                <div class="filter-section">
                    <h4>Causation Types</h4>
                    <div class="filter-item">
                        <label><input type="checkbox" id="filter-threshold" checked onchange="applyFilters()">
                            <span>Threshold</span></label>
                    </div>
                    <div class="filter-item">
                        <label><input type="checkbox" id="filter-correlation" checked onchange="applyFilters()">
                            <span>Correlation</span></label>
                    </div>
                    <div class="filter-item">
                        <label><input type="checkbox" id="filter-direct" checked onchange="applyFilters()">
                            <span>Direct</span></label>
                    </div>
                    <div class="filter-item">
                        <label><input type="checkbox" id="filter-temporal" checked onchange="applyFilters()">
                            <span>Temporal</span></label>
                    </div>
                </div>
                
                <div class="filter-section">
                    <h4>Show Controls</h4>
                    <div class="filter-item">
                        <label><input type="checkbox" id="show-labels" checked onchange="toggleLabels()">
                            <span>Node Labels</span></label>
                    </div>
                    <div class="filter-item">
                        <label><input type="checkbox" id="show-links" checked onchange="toggleLinks()">
                            <span>Causation Links</span></label>
                    </div>
                    <div class="filter-item">
                        <label><input type="checkbox" id="show-temporal-paths" onchange="toggleTemporalPaths()">
                            <span>Temporal Paths</span></label>
                    </div>
                </div>
                
                <div class="filter-section" style="border-top: 2px solid #0ff; margin-top: 20px; padding-top: 15px;">
                    <h4 style="color: #ff0;">‚öôÔ∏è Ollama Settings</h4>
                    <div class="filter-item" style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px; color: #0ff;">
                            <input type="checkbox" id="ollamaCloudMode" onchange="toggleCloudMode()" style="margin-right: 5px;">
                            <span>Use Ollama Cloud</span>
                        </label>
                        <div id="cloudSettings" style="display: none; margin-top: 10px; padding: 10px; background: #000; border: 1px solid #0aa;">
                            <label style="display: block; margin-bottom: 5px; color: #0ff; font-size: 0.9em;">API Key:</label>
                            <input type="password" id="ollamaApiKey" placeholder="Enter your API key" 
                                   style="width: 100%; padding: 5px; background: #111; border: 1px solid #0aa; color: #0ff; font-size: 0.85em; margin-bottom: 10px;">
                            <button onclick="saveOllamaConfig()" style="width: 100%; padding: 5px; background: #0aa; border: 1px solid #0ff; color: #0ff; cursor: pointer; font-size: 0.85em;">
                                üíæ Save & Apply
                            </button>
                            <div id="configStatus" style="margin-top: 5px; font-size: 0.8em; color: #0aa;"></div>
                        </div>
                        <div style="margin-top: 10px; font-size: 0.75em; color: #0aa;">
                            <a href="https://ollama.com/settings/keys" target="_blank" style="color: #0ff;">Get API Key ‚Üí</a>
                        </div>
                    </div>
                    <div id="ollamaConnectionStatus" style="margin-top: 10px; padding: 5px; background: #000; border: 1px solid #0aa; font-size: 0.85em; color: #0aa;">
                        Loading...
                    </div>
                </div>
                
                <button onclick="resetFilters()" style="width: 100%; margin-top: 10px;">Reset All Filters</button>
                
                <div class="filter-section" style="border-bottom: none; margin-top: 20px;">
                    <h4>üé¨ Export Art</h4>
                    <div style="margin: 10px 0;">
                        <label style="display: block; margin-bottom: 8px; color: #0ff; cursor: pointer;">
                            <input type="radio" name="exportFormat" value="mp4" checked style="margin-right: 5px;">
                            Cinematic MP4
                        </label>
                        <label style="display: block; margin-bottom: 8px; color: #0ff; cursor: pointer;">
                            <input type="radio" name="exportFormat" value="html" style="margin-right: 5px;">
                            Zoomable HTML
                        </label>
                    </div>
                    <div style="margin: 10px 0;">
                        <label style="display: block; color: #0aa; font-size: 0.85em; margin-bottom: 3px;">Duration (seconds):</label>
                        <input type="number" id="exportDuration" value="60" min="5" max="600" style="width: 100%; padding: 5px; background: #000; border: 1px solid #0aa; color: #0ff; margin-bottom: 8px;">
                        <label style="display: block; color: #0aa; font-size: 0.85em; margin-bottom: 3px;">FPS (frames per second):</label>
                        <input type="number" id="exportFPS" value="30" min="15" max="60" style="width: 100%; padding: 5px; background: #000; border: 1px solid #0aa; color: #0ff; margin-bottom: 10px;">
                        <div style="font-size: 0.75em; color: #888; margin-bottom: 5px;">
                            At 60 sec / 30 FPS = 1,800 frames
                        </div>
                        <button onclick="startExport()" style="width: 100%; padding: 10px; background: #0aa; border: 1px solid #0ff; color: #0ff; cursor: pointer; font-weight: bold;">
                            üé¨ Export Video
                        </button>
                        <div id="exportStatus" style="margin-top: 10px; color: #0f0; font-size: 0.85em; display: none;"></div>
                    </div>
                </div>
                
                <div class="filter-section" style="border-bottom: none; margin-top: 20px;">
                    <h4>Navigation Help</h4>
                    <div style="font-size: 0.85em; color: #0aa;">
                        <div style="margin: 5px 0;"><strong>Click:</strong> Navigate buttons</div>
                        <div style="margin: 5px 0;"><strong>Arrows:</strong> Pan view</div>
                        <div style="margin: 5px 0;"><strong>+/-:</strong> Smooth zoom</div>
                        <div style="margin: 5px 0;"><strong>Shift +/-:</strong> Fine zoom</div>
                        <div style="margin: 5px 0;"><strong>R/Q:</strong> Rotate</div>
                        <div style="margin: 5px 0;"><strong>Home:</strong> Reset view</div>
                        <div style="margin: 5px 0;"><strong>F:</strong> Fit all nodes</div>
                        <div style="margin: 5px 0; color: #0aa; font-size: 0.85em;">
                            Gradual layer-by-layer navigation
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Graph Container -->
            <div class="graph-container">
                <div class="graph-controls">
                    <div class="graph-controls-row">
                        <button class="nav-button" onclick="panGraph('up')">‚Üë</button>
                    </div>
                    <div class="graph-controls-row">
                        <button class="nav-button" onclick="panGraph('left')">‚Üê</button>
                        <button class="nav-button" onclick="resetView()">‚åÇ</button>
                        <button class="nav-button" onclick="panGraph('right')">‚Üí</button>
                    </div>
                    <div class="graph-controls-row">
                        <button class="nav-button" onclick="panGraph('down')">‚Üì</button>
                    </div>
                    <div class="graph-controls-row">
                        <button class="nav-button" onclick="zoomGraph('in')" title="Zoom in (smooth)">+</button>
                        <button class="nav-button" onclick="zoomGraph('out')" title="Zoom out (smooth)">‚àí</button>
                    </div>
                    <div class="graph-controls-row">
                        <button class="nav-button" onclick="zoomFine('in')" title="Fine zoom in">++</button>
                        <button class="nav-button" onclick="zoomFine('out')" title="Fine zoom out">‚àí‚àí</button>
                    </div>
                    <div class="graph-controls-row" style="font-size: 0.7em; color: #0aa; padding-top: 5px;">
                        <input type="number" id="zoomInput" value="5" min="1" max="500" step="1" 
                               style="width: 60px; background: #000; border: 1px solid #0aa; color: #0ff; text-align: center; font-size: 0.9em; padding: 2px;"
                               onchange="setZoomFromInput()" 
                               onkeypress="if(event.key === 'Enter') setZoomFromInput()">
                        <span style="color: #0aa; margin-left: 3px;">%</span>
                        <button class="nav-button" onclick="document.getElementById('zoomInput').focus()" title="Click to edit zoom" style="margin-left: 5px; font-size: 0.8em; padding: 2px 5px;">‚úé</button>
                    </div>
                    <div class="graph-controls-row" style="gap: 3px; flex-wrap: wrap; justify-content: center; margin-top: 5px;">
                        <button class="nav-button" onclick="setZoomPreset(0.01)" title="1% - Maximum overview" style="font-size: 0.75em; padding: 2px 5px;">1%</button>
                        <button class="nav-button" onclick="setZoomPreset(0.05)" title="5% - Standard overview" style="font-size: 0.75em; padding: 2px 5px;">5%</button>
                        <button class="nav-button" onclick="setZoomPreset(0.5)" title="50% - Detailed view" style="font-size: 0.75em; padding: 2px 5px;">50%</button>
                        <button class="nav-button" onclick="setZoomPreset(5.0)" title="500% - Maximum detail" style="font-size: 0.75em; padding: 2px 5px;">500%</button>
                    </div>
                    <div class="graph-controls-row">
                        <button class="nav-button" onclick="zoomToFit()" title="Zoom to fit all nodes">‚õ∂</button>
                    </div>
                    <div class="graph-controls-row">
                        <button class="nav-button" onclick="rotateGraph('cw')">‚Üª</button>
                        <button class="nav-button" onclick="rotateGraph('ccw')">‚Ü∫</button>
                    </div>
                </div>
        <div id="graph"></div>
            </div>
        </div>
        
        <!-- Convergence Research Assistant (CRA) Chat Interface - Below graph, aligned to right of settings panel -->
        <div class="main-content" style="align-items: flex-start; margin-top: -50px;">
            <!-- Spacer to align with settings panel width -->
            <div style="width: 250px; flex-shrink: 0;"></div>
            
            <!-- Chat panel positioned where graph is -->
            <div class="chat-panel-wrapper">
                <div class="info-panel" id="craChatPanel">
                    <h3>üß† Convergence Research Assistant (CRA)</h3>
                    <div style="margin-bottom: 10px;">
                        <div style="margin-bottom: 8px;">
                            <label style="color: #0ff; display: block; margin-bottom: 5px; font-size: 0.9em;">Research Model:</label>
                            <select id="researchModelSelect" style="width: 100%; background: #111; color: #0f0; border: 1px solid #0ff; padding: 5px; font-family: 'Courier New', monospace; font-size: 0.9em;">
                                <option value="">Loading models...</option>
                            </select>
                            <div style="font-size: 0.75em; color: #888; margin-top: 3px;">
                                Text model for answering questions about the system
                            </div>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <label style="color: #0ff; display: block; margin-bottom: 5px; font-size: 0.9em;">Vision Model:</label>
                            <select id="visionModelSelect" style="width: 100%; background: #111; color: #0f0; border: 1px solid #0ff; padding: 5px; font-family: 'Courier New', monospace; font-size: 0.9em;">
                                <option value="">Loading models...</option>
                            </select>
                            <div style="font-size: 0.75em; color: #888; margin-top: 3px;">
                                Vision model (like llava) for analyzing graph screenshots
                            </div>
                        </div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; gap: 5px;">
                        <label style="color: #0ff; font-size: 0.9em; font-weight: bold;">Chat Log</label>
                        <button onclick="copyAllChat()" style="padding: 4px 10px; background: #0aa; border: 1px solid #0ff; color: #0ff; cursor: pointer; font-size: 0.8em; font-family: 'Courier New', monospace;" title="Copy all chat messages to clipboard">üìã Copy All</button>
                        <button onclick="exportAnalysis()" style="padding: 4px 10px; background: #0aa; border: 1px solid #0ff; color: #0ff; cursor: pointer; font-size: 0.8em; font-family: 'Courier New', monospace;" title="Export analysis report to file">üíæ Export</button>
                    </div>
                    <div id="chatMessages" style="height: 550px; overflow-y: auto; background: #000; border: 1px solid #0ff; padding: 10px; margin-bottom: 10px; font-size: 0.9em;">
                        <div style="color: #0aa; margin-bottom: 10px;">CRA: Hello! I'm your Convergence Research Assistant. I have access to all system logs, shared state, and the causation graph. Ask me anything about the Butterfly System!</div>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="chatInput" placeholder="Ask about the system..." style="flex: 1; padding: 8px; background: #111; color: #0f0; border: 1px solid #0ff; font-family: 'Courier New', monospace;" onkeypress="if(event.key === 'Enter') sendChatMessage()">
                        <button onclick="sendChatMessage()" style="padding: 8px 15px;">Send</button>
                    </div>
                    <div id="chatStatus" style="color: #0aa; font-size: 0.8em; margin-top: 5px;"></div>
                </div>
            </div>
        </div>
        
        <!-- Info panels below main content -->
        <div style="margin-top: -50px;">
        <div class="info-panel">
            <h3>Selected Event</h3>
            <div id="eventInfo">Click an event to explore</div>
        </div>
        
        <div class="info-panel">
            <h3>Causation Trail (What Caused This?)</h3>
            <div id="backwardsTrail">Explore backwards to see causes</div>
        </div>
        
        <div class="info-panel">
            <h3>Effects (What Did This Cause?)</h3>
            <div id="forwardsTrail">Explore forwards to see effects</div>
        </div>
        </div>
    </div>
    
    <script>
        let svg, simulation, graphGroup;
        let selectedNode = null;
        let allNodes = [], allLinks = [];
        let filteredNodes = [], filteredLinks = [];
        
        // Navigation state
        let panX = 0, panY = 0;
        let zoomLevel = 0.05; // Default 5% zoom for overview
        let rotation = 0;
        
        // Live mode state
        let liveMode = false;
        let liveModeInterval = null;
        let lastEventTimestamp = 0;
        let lastGraphUpdate = 0;
        
        // Evolutionary snapshot history for vision model
        let snapshotHistory = [];
        const MAX_SNAPSHOTS = 10; // Keep last 10 snapshots (with compression, can send more)
        const MAX_PAYLOAD_SIZE = 8000000; // Max 8MB total payload (safety limit for APIs)
        
        // Filter state
        let filters = {
            components: {
                'reality_sim': true,
                'reality_simulator': true,
                'explorer': true,
                'djinn_kernel': true,
                'utm_kernel': true,
                'breath': true,
                'system': true
            },
            causationTypes: {
                'threshold': true,
                'correlation': true,
                'direct': true,
                'temporal': true,
                'unknown': true
            },
            showLabels: true,
            showLinks: true
        };
        
        function loadGraph() {
            d3.json('/api/graph').then(data => {
                allNodes = data.nodes || [];
                allLinks = data.links || [];
                applyFilters();
            });
        }
        
        function applyFilters() {
            // Update filter state from checkboxes
            filters.components.reality_sim = document.getElementById('filter-reality_sim').checked;
            filters.components.reality_simulator = document.getElementById('filter-reality_sim').checked;
            filters.components.explorer = document.getElementById('filter-explorer').checked;
            filters.components.djinn_kernel = document.getElementById('filter-djinn_kernel').checked;
            filters.components.utm_kernel = document.getElementById('filter-djinn_kernel').checked;
            filters.components.breath = document.getElementById('filter-breath').checked;
            filters.components.system = document.getElementById('filter-system').checked;
            
            filters.causationTypes.threshold = document.getElementById('filter-threshold').checked;
            filters.causationTypes.correlation = document.getElementById('filter-correlation').checked;
            filters.causationTypes.direct = document.getElementById('filter-direct').checked;
            filters.causationTypes.temporal = document.getElementById('filter-temporal').checked;
            
            // Filter nodes by component
            filteredNodes = allNodes.filter(node => {
                const comp = node.component || 'unknown';
                return filters.components[comp] || filters.components['system'];
            });
            
            // Filter links by causation type and ensure both nodes are visible
            const visibleNodeIds = new Set(filteredNodes.map(n => n.id));
            filteredLinks = allLinks.filter(link => {
                const linkType = link.type || 'unknown';
                const hasSource = visibleNodeIds.has(link.source);
                const hasTarget = visibleNodeIds.has(link.target);
                return filters.causationTypes[linkType] && hasSource && hasTarget;
            });
            
            // Rebuild link source/target references - keep as IDs for simulation
            const nodeMap = new Map(filteredNodes.map(n => [n.id, n]));
            filteredLinks = filteredLinks.map(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                return {
                    ...link,
                    source: sourceId,
                    target: targetId
                };
            }).filter(link => nodeMap.has(link.source) && nodeMap.has(link.target));
            
            // If graph hasn't been rendered yet, render it with filters
            if (!svg || !simulation) {
                renderGraph();
            } else {
                // Graph already exists - just update visibility without resetting
                updateFilterVisibility();
            }
        }
        
        function updateFilterVisibility() {
            // Calculate which nodes should be visible
            const visibleNodeIds = new Set();
            allNodes.forEach(node => {
                const comp = node.component || 'unknown';
                const shouldShow = filters.components[comp] || filters.components['system'];
                if (shouldShow) {
                    visibleNodeIds.add(node.id);
                }
            });
            
            // Update node visibility (preserve positions)
            if (svg) {
                svg.selectAll('.node')
                    .style('display', d => {
                        const comp = d.component || 'unknown';
                        const shouldShow = filters.components[comp] || filters.components['system'];
                        return shouldShow ? 'block' : 'none';
                    });
            }
            
            // Update link visibility (check both causation type and node visibility)
            if (svg) {
                svg.selectAll('.link')
                    .style('display', d => {
                        const linkType = (d.type || d.causation_type || 'unknown').toLowerCase();
                        // Handle both ID strings and node objects (D3 converts IDs to objects)
                        const sourceId = typeof d.source === 'object' && d.source.id ? d.source.id : (typeof d.source === 'object' ? d.source : d.source);
                        const targetId = typeof d.target === 'object' && d.target.id ? d.target.id : (typeof d.target === 'object' ? d.target : d.target);
                        const hasSource = visibleNodeIds.has(sourceId);
                        const hasTarget = visibleNodeIds.has(targetId);
                        const typeAllowed = filters.causationTypes[linkType] !== false;
                        return (typeAllowed && hasSource && hasTarget) ? 'block' : 'none';
                    });
            }
            
            // Update simulation to only include visible nodes (preserve positions with gentle restart)
            if (simulation) {
                // Get currently visible nodes (preserve their positions from simulation)
                const visibleNodes = allNodes.filter(node => {
                    const comp = node.component || 'unknown';
                    return filters.components[comp] || filters.components['system'];
                }).map(node => {
                    // Find existing node in simulation to preserve position
                    const existing = simulation.nodes().find(n => n.id === node.id);
                    if (existing) {
                        return existing; // Keep existing position
                    }
                    return node; // New node
                });
                
                // Get currently visible links
                const visibleLinks = allLinks.filter(link => {
                    const linkType = (link.type || link.causation_type || 'unknown').toLowerCase();
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    const hasSource = visibleNodeIds.has(sourceId);
                    const hasTarget = visibleNodeIds.has(targetId);
                    return filters.causationTypes[linkType] !== false && hasSource && hasTarget;
                }).map(link => ({
                    ...link,
                    source: typeof link.source === 'object' ? link.source.id : link.source,
                    target: typeof link.target === 'object' ? link.target.id : link.target
                }));
                
                // Update simulation nodes and links (preserves existing positions)
                simulation.nodes(visibleNodes);
                simulation.force('link').links(visibleLinks);
                simulation.alpha(0.05).restart(); // Very gentle restart to adjust layout slightly
            }
        }
        
        function resetFilters() {
            document.querySelectorAll('.filter-panel input[type="checkbox"]').forEach(cb => cb.checked = true);
            applyFilters();
        }
        
        function toggleLabels() {
            filters.showLabels = document.getElementById('show-labels').checked;
            if (svg) {
                svg.selectAll('.node text').style('display', filters.showLabels ? 'block' : 'none');
            }
        }
        
        function toggleLinks() {
            filters.showLinks = document.getElementById('show-links').checked;
            if (svg) {
                svg.selectAll('.link').style('display', filters.showLinks ? 'block' : 'none');
            }
        }
        
        function toggleTemporalPaths() {
            filters.showTemporalPaths = document.getElementById('show-temporal-paths').checked;
            if (svg) {
                // Remove existing temporal paths
                svg.selectAll('.temporal-path').remove();
                
                if (filters.showTemporalPaths && filteredNodes.length > 0) {
                    // Add temporal path visualization
                    addTemporalPaths(filteredNodes, filteredLinks);
                }
            }
        }
        
        // Add temporal trajectory paths
        function addTemporalPaths(nodes) {
            if (!graphGroup || !nodes || nodes.length === 0) return;
            
            // Remove existing paths
            graphGroup.selectAll('.temporal-path').remove();
            
            // Sort nodes by timestamp
            const sortedNodes = [...nodes].filter(n => n.timestamp).sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
            
            if (sortedNodes.length < 2) return;
            
            // Group nodes by component and create trajectories
            const componentPaths = {};
            sortedNodes.forEach(node => {
                const comp = node.component || 'unknown';
                if (!componentPaths[comp]) {
                    componentPaths[comp] = [];
                }
                componentPaths[comp].push(node);
            });
            
            // Draw temporal paths for each component
            Object.entries(componentPaths).forEach(([component, pathNodes]) => {
                if (pathNodes.length < 2) return;
                
                // Create path line following temporal sequence
                const line = d3.line()
                    .x(d => d.x || 0)
                    .y(d => d.y || 0)
                    .curve(d3.curveCardinal);
                
                const pathData = pathNodes.map(n => ({
                    x: n.x || 0,
                    y: n.y || 0
                }));
                
                graphGroup.append('path')
                    .datum(pathData)
                    .attr('class', 'temporal-path')
                    .attr('d', line)
                    .attr('fill', 'none')
                    .attr('stroke', getComponentColor(component))
                    .attr('stroke-width', 2)
                    .attr('stroke-opacity', 0.3)
                    .attr('stroke-dasharray', '5,5')
                    .lower(); // Send to back
            });
        }
        
        // Update temporal paths on simulation tick
        function updateTemporalPaths() {
            if (!graphGroup || !simulation) return;
            
            graphGroup.selectAll('.temporal-path').each(function() {
                const path = d3.select(this);
                const pathData = path.datum();
                
                // Update path data with current node positions
                const updatedData = pathData.map(p => {
                    const node = simulation.nodes().find(n => 
                        Math.abs((n.x || 0) - p.x) < 1 && Math.abs((n.y || 0) - p.y) < 1
                    );
                    if (node) {
                        return { x: node.x || 0, y: node.y || 0 };
                    }
                    return p;
                });
                
                const line = d3.line()
                    .x(d => d.x || 0)
                    .y(d => d.y || 0)
                    .curve(d3.curveCardinal);
                
                path.attr('d', line(updatedData));
            });
        }
        
        function renderGraph() {
            d3.select('#graph').selectAll('*').remove();
            
            const width = document.getElementById('graph').clientWidth;
            const height = 792; // Match increased graph container height
            
            svg = d3.select('#graph')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Create transform group for pan/zoom/rotate
            graphGroup = svg.append('g')
                .attr('class', 'graph-group');
            
            updateTransform();
            
            const links = filteredLinks.map(d => ({...d}));
            const nodes = filteredNodes.map(d => ({...d}));
            
            // Create link elements
            const link = graphGroup.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(links, d => d.source.id + '-' + d.target.id)
                .enter().append('line')
                .attr('class', 'link')
                .attr('data-link-id', (d, i) => 'link-' + i)
                .attr('stroke', d => getLinkColor(d.type || d.causation_type || 'unknown'))
                .attr('stroke-width', d => Math.max(2, (d.strength || 0.5) * 5))
                .attr('stroke-opacity', d => Math.min(0.8, 0.4 + (d.strength || 0.5)))
                .style('display', filters.showLinks ? 'block' : 'none');
            
            // Create node elements
            const node = graphGroup.append('g')
                .attr('class', 'nodes')
                .selectAll('g')
                .data(nodes, d => d.id)
                .enter().append('g')
                .attr('class', 'node')
                .attr('data-node-id', d => d.id)
                .on('click', (event, d) => selectNode(d));
            
            node.append('circle')
                .attr('r', d => 10 + (d.type ? 2 : 0))  // Larger nodes
                .attr('fill', d => getComponentColor(d.component))
                .attr('stroke', '#FFFFFF')
                .attr('stroke-width', 3);
            
            node.append('text')
                .text(d => {
                    const comp = d.component || 'unknown';
                    return comp.substring(0, 12).toUpperCase();
                })
                .attr('data-node-id', d => d.id)
                .attr('dx', 15)
                .attr('dy', 5)
                .attr('font-size', '11px')
                .attr('font-weight', 'bold')
                .attr('fill', '#000000')
                .attr('stroke', '#FFFFFF')
                .attr('stroke-width', '2px')
                .attr('stroke-linejoin', 'round')
                .attr('paint-order', 'stroke fill')
                .style('display', filters.showLabels ? 'block' : 'none');
            
            // Simulation - D3 force simulation will convert IDs to node references
            // Initialize nodes with random positions (not predetermined template)
            // This makes each load look unique and organic, not template-like
            nodes.forEach(node => {
                if (!node.x && !node.y) {
                    // Random position in a circle around center (distributes nodes organically)
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * Math.min(width, height) * 0.3; // 30% of viewport
                    node.x = width / 2 + Math.cos(angle) * radius;
                    node.y = height / 2 + Math.sin(angle) * radius;
                }
            });
            
            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .velocityDecay(0.6); // Higher decay = more stable, less jittery
            
            // Add temporal trajectories overlay (shows paths through time)
            if (filters.showTemporalPaths) {
                addTemporalPaths(nodes, links);
            }
            
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x || 0)
                    .attr('y1', d => d.source.y || 0)
                    .attr('x2', d => d.target.x || 0)
                    .attr('y2', d => d.target.y || 0);
                
                node
                    .attr('transform', d => `translate(${d.x || 0},${d.y || 0})`);
                
                // Update temporal paths if enabled
                if (filters.showTemporalPaths) {
                    updateTemporalPaths();
                }
            });
            
            // Initial temporal paths if enabled
            if (filters.showTemporalPaths) {
                simulation.on('end', () => {
                    addTemporalPaths(nodes);
                });
            }
        }
        
        // Navigation functions
        function updateTransform() {
            if (!graphGroup) return;
            const centerX = document.getElementById('graph').clientWidth / 2;
            const centerY = 300;
            
            graphGroup.attr('transform', `
                translate(${centerX + panX}, ${centerY + panY})
                scale(${zoomLevel})
                rotate(${rotation})
                translate(${-centerX}, ${-centerY})
            `);
            
            // Update zoom level display
            const zoomInput = document.getElementById('zoomInput');
            if (zoomInput) {
                const percent = Math.round(zoomLevel * 100);
                zoomInput.value = percent;
            }
        }
        
        function panGraph(direction) {
            const increment = 30;
            switch(direction) {
                case 'up': panY += increment; break;
                case 'down': panY -= increment; break;
                case 'left': panX += increment; break;
                case 'right': panX -= increment; break;
            }
            updateTransform();
        }
        
        function zoomGraph(direction) {
            // Logarithmic zoom for smooth transitions through layers
            // Each step feels like moving through a layer, not jumping
            const currentZoom = zoomLevel;
            let newZoom;
            
            if (direction === 'in') {
                // Zooming in: exponential growth that slows near max
                // Base increment scales with current zoom level
                const baseIncrement = 0.05; // Small base increment
                const scaleFactor = Math.max(0.5, 1 - (currentZoom / 5)); // Slows as we approach max
                const increment = baseIncrement * scaleFactor;
                newZoom = Math.min(5, currentZoom * (1 + increment));
            } else {
                // Zooming out: logarithmic decrease that slows near min
                // Makes it feel like you're peeling back layers gradually
                const baseDecrement = 0.08; // Small base decrement
                const scaleFactor = Math.max(0.3, currentZoom / 0.5); // Slows as we approach min
                const decrement = baseDecrement / scaleFactor;
                newZoom = Math.max(0.01, currentZoom / (1 + decrement));
                
                // Additional soft cap: if already very zoomed out, slow even more
                if (currentZoom < 0.1) {
                    newZoom = Math.max(0.01, currentZoom * 0.9); // 10% reduction when very far out
                }
            }
            
            zoomLevel = newZoom;
            updateTransform();
        }
        
        // Fine-grained zoom for precise control
        function zoomFine(direction) {
            const fineIncrement = direction === 'in' ? 1.05 : 0.95; // 5% per step
            zoomLevel = Math.max(0.01, Math.min(5, zoomLevel * fineIncrement));
            updateTransform();
        }
        
        function zoomToFit() {
            if (!simulation || filteredNodes.length === 0) return;
            
            // Get bounding box of all nodes
            const xs = filteredNodes.map(n => n.x || 0);
            const ys = filteredNodes.map(n => n.y || 0);
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            
            const width = maxX - minX || 1;
            const height = maxY - minY || 1;
            const graphWidth = document.getElementById('graph').clientWidth;
            const graphHeight = 792; // Match increased graph container height
            
            // Calculate zoom to fit with padding
            const padding = 50;
            const scaleX = (graphWidth - padding * 2) / width;
            const scaleY = (graphHeight - padding * 2) / height;
            zoomLevel = Math.min(scaleX, scaleY, 5); // Don't zoom in more than 5x
            
            // Center the view
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            panX = (graphWidth / 2) - (centerX * zoomLevel);
            panY = (graphHeight / 2) - (centerY * zoomLevel);
            
            updateTransform();
        }
        
        function rotateGraph(direction) {
            const increment = 15;
            if (direction === 'cw') {
                rotation = (rotation + increment) % 360;
            } else {
                rotation = (rotation - increment + 360) % 360;
            }
            updateTransform();
        }
        
        function resetView() {
            panX = 0;
            panY = 0;
            zoomLevel = 0.05; // Reset to 5% zoom for overview
            rotation = 0;
            updateTransform();
        }
        
        // Set zoom from input field
        function setZoomFromInput() {
            const zoomInput = document.getElementById('zoomInput');
            if (!zoomInput) return;
            
            const percent = parseFloat(zoomInput.value);
            if (isNaN(percent) || percent < 1 || percent > 500) {
                // Invalid input, restore current value
                zoomInput.value = Math.round(zoomLevel * 100);
                return;
            }
            
            zoomLevel = percent / 100; // Convert percentage to scale
            updateTransform();
        }
        
        // Set zoom to preset value
        function setZoomPreset(scale) {
            zoomLevel = scale;
            updateTransform();
        }
        
        // Allow clicking on zoom display to edit
        function editZoom() {
            const zoomInput = document.getElementById('zoomInput');
            if (zoomInput) {
                zoomInput.focus();
                zoomInput.select();
            }
        }
        
        function getComponentColor(component) {
            const colors = {
                'reality_sim': '#00FFFF',      // Bright Cyan
                'explorer': '#FFFF00',         // Bright Yellow
                'djinn_kernel': '#FF00FF',     // Bright Magenta
                'breath': '#00FF00',           // Bright Green
                'system': '#FFFFFF',           // White
                'reality_simulator': '#00FFFF',
                'utm_kernel': '#FF00FF'
            };
            return colors[component] || '#FF6600'; // Bright Orange for unknown
        }
        
        function getLinkColor(linkType) {
            if (!linkType) return '#0aa';
            const linkColors = {
                'threshold': '#ff00ff',        // Magenta for thresholds
                'correlation': '#00ffff',      // Cyan for correlations
                'direct': '#00ff00',           // Green for direct
                'temporal': '#ffff00',         // Yellow for temporal
                'unknown': '#ff6600'           // Orange for unknown
            };
            return linkColors[linkType.toLowerCase()] || linkColors['unknown'];
        }
        
        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return; // Don't interfere with typing
            
            switch(e.key) {
                case 'ArrowUp': e.preventDefault(); panGraph('up'); break;
                case 'ArrowDown': e.preventDefault(); panGraph('down'); break;
                case 'ArrowLeft': e.preventDefault(); panGraph('left'); break;
                case 'ArrowRight': e.preventDefault(); panGraph('right'); break;
                case '+':
                case '=': 
                    if (e.shiftKey) {
                        e.preventDefault(); zoomFine('in'); 
                    } else {
                        e.preventDefault(); zoomGraph('in'); 
                    }
                    break;
                case '-':
                case '_': 
                    if (e.shiftKey) {
                        e.preventDefault(); zoomFine('out'); 
                    } else {
                        e.preventDefault(); zoomGraph('out'); 
                    }
                    break;
                case 'r':
                case 'R': e.preventDefault(); rotateGraph('cw'); break;
                case 'q':
                case 'Q': e.preventDefault(); rotateGraph('ccw'); break;
                case 'Home':
                case '0': e.preventDefault(); resetView(); break;
                case 'f':
                case 'F': e.preventDefault(); zoomToFit(); break;
            }
        });
        
        
        function selectNode(node) {
            selectedNode = node;
            updateEventInfo(node);
            exploreBackwards(node.id);
            exploreForwards(node.id);
        }
        
        function updateEventInfo(node) {
            d3.json(`/api/events/${node.id}`).then(data => {
                const info = document.getElementById('eventInfo');
                const component = data.event.component || 'unknown';
                const eventType = data.event.event_type || 'unknown';
                const timestamp = new Date(data.event.timestamp * 1000).toLocaleString();
                info.innerHTML = `
                    <div class="event-item">
                        <div style="margin-bottom: 10px;">
                            <span class="component">${component.toUpperCase()}</span> 
                            <span style="color: #0f0;"> ‚Üí </span> 
                            <span class="event-type">${eventType}</span>
                        </div>
                        <div style="margin: 8px 0;">
                            <span class="metric">Timestamp:</span> 
                            <span class="timestamp">${timestamp}</span>
                        </div>
                        <div style="margin: 8px 0;">
                            <span class="metric">Data:</span><br>
                            <pre>${JSON.stringify(data.event.data, null, 2)}</pre>
                        </div>
                        <div style="margin: 8px 0;">
                            <span class="metric">Caused by:</span> <span class="count-value">${data.caused_by}</span> events
                            <span style="margin-left: 20px;" class="metric">Caused:</span> <span class="count-value">${data.caused}</span> events
                        </div>
                    </div>
                `;
            }).catch(err => {
                console.error('Error fetching event info:', err);
                document.getElementById('eventInfo').innerHTML = `<div style="color: #f00; padding: 10px; border: 1px solid #f00;">Error loading event: ${err.message}</div>`;
            });
        }
        
        function exploreBackwards(eventId) {
            d3.json(`/api/events/${eventId}/backwards?depth=5`).then(trail => {
                const trailDiv = document.getElementById('backwardsTrail');
                if (!trail || trail.length === 0) {
                    trailDiv.innerHTML = '<div style="color: #888; padding: 10px;">No causation trail found (root cause)</div>';
                    return;
                }
                trailDiv.innerHTML = trail.map((item, idx) => {
                    const component = item.event.component || 'unknown';
                    return `
                        <div class="event-item causation-trail" style="margin-left: ${item.depth * 20}px;">
                            <div style="margin-bottom: 8px;">
                                <span class="depth-indicator">[Depth ${item.depth}]</span>
                                <span class="component">${component.toUpperCase()}</span>
                                <span style="color: #0f0;"> ‚Üí </span>
                                <span class="event-type">${item.event.event_type}</span>
                    </div>
                            <pre>${JSON.stringify(item.event.data, null, 2)}</pre>
                        </div>
                    `;
                }).join('');
            }).catch(err => {
                console.error('Error exploring backwards:', err);
                document.getElementById('backwardsTrail').innerHTML = `<div style="color: #f00; padding: 10px; border: 1px solid #f00;">Error: ${err.message}</div>`;
            });
        }
        
        function exploreForwards(eventId) {
            d3.json(`/api/events/${eventId}/forwards?depth=5`).then(trail => {
                const trailDiv = document.getElementById('forwardsTrail');
                if (!trail || trail.length === 0) {
                    trailDiv.innerHTML = '<div style="color: #888; padding: 10px;">No effects found (leaf event)</div>';
                    return;
                }
                trailDiv.innerHTML = trail.map((item, idx) => {
                    const component = item.event.component || 'unknown';
                    return `
                        <div class="event-item causation-trail" style="margin-left: ${item.depth * 20}px;">
                            <div style="margin-bottom: 8px;">
                                <span class="depth-indicator">[Effect ${item.depth}]</span>
                                <span class="component">${component.toUpperCase()}</span>
                                <span style="color: #0f0;"> ‚Üí </span>
                                <span class="event-type">${item.event.event_type}</span>
                    </div>
                            <pre>${JSON.stringify(item.event.data, null, 2)}</pre>
                        </div>
                    `;
                }).join('');
            }).catch(err => {
                console.error('Error exploring forwards:', err);
                document.getElementById('forwardsTrail').innerHTML = `<div style="color: #f00; padding: 10px; border: 1px solid #f00;">Error: ${err.message}</div>`;
            });
        }
        
        function searchEvents() {
            const query = document.getElementById('searchInput').value;
            if (!query || query.trim() === '') {
                alert('Please enter a search query');
                return;
            }
            d3.json(`/api/events/search?q=${query}`).then(results => {
                const info = document.getElementById('eventInfo');
                if (!results || results.length === 0) {
                    info.innerHTML = `<div style="color: #FF6600; padding: 15px; border: 3px solid #FF6600; text-align: center; font-size: 1.2em;">No events found matching "${query}"</div>`;
                    return;
                }
                info.innerHTML = `
                        <div style="margin-bottom: 15px; padding: 10px; background: #111; border: 1px solid #0ff;">
                            <strong>Search Results:</strong> <span class="count-value">${results.length}</span> events found
                        </div>
                        ${results.slice(0, 10).map(event => {
                            const component = event.component || 'unknown';
                            return `
                                <div class="event-item" onclick="selectEvent('${event.event_id}')" style="cursor: pointer;">
                                    <div style="margin-bottom: 8px;">
                                        <span class="component">${component.toUpperCase()}</span>
                                        <span style="color: #0f0;"> ‚Üí </span>
                                        <span class="event-type">${event.event_type}</span>
                                    </div>
                                    <pre>${JSON.stringify(event.data, null, 2)}</pre>
                                </div>
                            `;
                        }).join('')}
                        ${results.length > 10 ? `<div style="color: #888; padding: 10px; text-align: center;">... and ${results.length - 10} more results</div>` : ''}
                    `;
            }).catch(err => {
                console.error('Error searching events:', err);
                document.getElementById('eventInfo').innerHTML = `<div style="color: #FF0000; padding: 10px; border: 3px solid #FF0000;">Search error: ${err.message}</div>`;
            });
        }
        
        function selectEvent(eventId) {
            d3.json(`/api/events/${eventId}`).then(data => {
                selectNode({id: eventId, component: data.event.component, event_type: data.event.event_type});
            });
        }
        
        // Export functions
        let isExporting = false;
        let exportFrames = [];
        let exportStartTime = null;
        let exportCameraMovements = [];
        
        function startExport() {
            if (!svg || !simulation) {
                alert('Please load the graph first!');
                return;
            }
            
            if (isExporting) {
                alert('Export already in progress!');
                return;
            }
            
            const format = document.querySelector('input[name="exportFormat"]:checked').value;
            const duration = parseInt(document.getElementById('exportDuration').value) || 60;
            const fps = parseInt(document.getElementById('exportFPS').value) || 30;
            const totalFrames = duration * fps;
            
            const statusDiv = document.getElementById('exportStatus');
            statusDiv.style.display = 'block';
            
            if (format === 'mp4') {
                exportCinematicMP4(duration, fps, totalFrames, statusDiv);
            } else if (format === 'html') {
                exportInteractiveHTML(duration, fps, totalFrames, statusDiv);
            }
        }
        
        function exportCinematicMP4(duration, fps, totalFrames, statusDiv) {
            isExporting = true;
            exportFrames = [];
            exportCameraMovements = [];
            exportStartTime = Date.now();
            
            // Convert SVG to Canvas for better video quality
            const svgElement = svg.node();
            const svgData = new XMLSerializer().serializeToString(svgElement);
            const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
            const svgUrl = URL.createObjectURL(svgBlob);
            
            const canvas = document.createElement('canvas');
            canvas.width = document.getElementById('graph').clientWidth;
            canvas.height = 792; // Match increased graph container height
            const ctx = canvas.getContext('2d');
            
            const img = new Image();
            img.onload = function() {
                // Plan cinematic camera movements
                planCinematicMovements(duration);
                
                // Record frames
                recordFrames(ctx, canvas, img, 0, totalFrames, fps, duration, statusDiv, true);
            };
            img.src = svgUrl;
        }
        
        function exportInteractiveHTML(duration, fps, totalFrames, statusDiv) {
            isExporting = true;
            exportFrames = [];
            exportCameraMovements = [];
            exportStartTime = Date.now();
            
            statusDiv.innerHTML = 'üìπ Recording interactive timeline...';
            
            // Record timeline data (node positions + camera state at each frame)
            recordTimeline(0, totalFrames, fps, duration, statusDiv);
        }
        
        function planCinematicMovements(duration) {
            // Plan smooth camera movements for cinematic effect
            // Zoom out gradually from 3% to 2% as graph expands
            const totalFrames = duration * 30; // 30 fps planning
            
            exportCameraMovements = [];
            
            for (let i = 0; i <= totalFrames; i++) {
                const t = i / totalFrames; // 0.0 to 1.0
                
                // Smooth zoom out from 3% to 2% over entire duration
                // Using ease-out curve for smooth deceleration
                const easeOut = 1 - Math.pow(1 - t, 3); // Cubic ease-out
                const startZoom = 0.03; // 3%
                const endZoom = 0.02; // 2%
                const currentZoom = startZoom + (endZoom - startZoom) * easeOut;
                
                // Subtle pan/rotation to add cinematic movement
                // Gentle circular motion that doesn't distract
                const panRadius = 50 * (1 - t); // Pan radius decreases as we zoom out
                const panSpeed = 0.3; // Slow rotation
                const panX = Math.sin(t * Math.PI * 2 * panSpeed) * panRadius;
                const panY = Math.cos(t * Math.PI * 2 * panSpeed) * panRadius;
                
                // Very subtle rotation
                const rotation = t * 45; // Rotate 45 degrees total over entire duration
                
                exportCameraMovements.push({
                    zoom: currentZoom,
                    panX: panX,
                    panY: panY,
                    rotation: rotation
                });
            }
        }
        
        function recordFrames(ctx, canvas, img, frameNum, totalFrames, fps, duration, statusDiv, isMP4) {
            if (frameNum >= totalFrames || !isExporting) {
                finishExport(isMP4, ctx, canvas, duration, fps, statusDiv);
                return;
            }
            
            const t = frameNum / fps;
            const movementIndex = Math.floor(t * 30); // 30 fps movements
            const cam = exportCameraMovements[movementIndex] || {zoom: zoomLevel, panX: panX, panY: panY, rotation: rotation};
            
            // Apply camera transform
            const savedZoom = zoomLevel;
            const savedPanX = panX;
            const savedPanY = panY;
            const savedRotation = rotation;
            
            zoomLevel = cam.zoom;
            panX = cam.panX;
            panY = cam.panY;
            rotation = cam.rotation;
            updateTransform();
            
            // Wait for simulation tick
            setTimeout(() => {
                // Capture frame
                if (isMP4) {
                    // For MP4: render SVG to canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    exportFrames.push(canvas.toDataURL('image/png'));
                } else {
                    // For HTML: save state
                    const frameData = {
                        t: t,
                        nodes: simulation.nodes().map(n => ({
                            id: n.id,
                            x: n.x,
                            y: n.y,
                            fx: n.fx,
                            fy: n.fy
                        })),
                        camera: {zoom: zoomLevel, panX: panX, panY: panY, rotation: rotation}
                    };
                    exportFrames.push(frameData);
                }
                
                // Restore camera
                zoomLevel = savedZoom;
                panX = savedPanX;
                panY = savedPanY;
                rotation = savedRotation;
                updateTransform();
                
                // Update status
                const progress = Math.round((frameNum / totalFrames) * 100);
                statusDiv.innerHTML = isMP4 
                    ? `üé¨ Recording MP4... ${progress}% (${frameNum}/${totalFrames} frames)`
                    : `üìπ Recording timeline... ${progress}% (${frameNum}/${totalFrames} frames)`;
                
                // Next frame
                requestAnimationFrame(() => {
                    recordFrames(ctx, canvas, img, frameNum + 1, totalFrames, fps, duration, statusDiv, isMP4);
                });
            }, 1000 / fps);
        }
        
        function recordTimeline(frameNum, totalFrames, fps, duration, statusDiv) {
            if (frameNum >= totalFrames || !isExporting) {
                finishInteractiveHTML(duration, fps, statusDiv);
                return;
            }
            
            const t = frameNum / fps;
            
            // Capture current state
            const frameData = {
                t: t,
                nodes: simulation.nodes().map(n => ({
                    id: n.id,
                    x: n.x,
                    y: n.y,
                    fx: n.fx,
                    fy: n.fy
                })),
                links: allLinks.map(l => ({
                    source: typeof l.source === 'object' ? l.source.id : l.source,
                    target: typeof l.target === 'object' ? l.target.id : l.target,
                    type: l.type || l.causation_type || 'unknown'
                })),
                camera: {zoom: zoomLevel, panX: panX, panY: panY, rotation: rotation}
            };
            
            exportFrames.push(frameData);
            
            // Update status
            const progress = Math.round((frameNum / totalFrames) * 100);
            statusDiv.innerHTML = `üìπ Recording timeline... ${progress}% (${frameNum}/${totalFrames} frames)`;
            
            // Next frame
            setTimeout(() => {
                recordTimeline(frameNum + 1, totalFrames, fps, duration, statusDiv);
            }, 1000 / fps);
        }
        
        function finishExport(isMP4, ctx, canvas, duration, fps, statusDiv) {
            if (!isMP4) return; // HTML export handled separately
            
            statusDiv.innerHTML = 'üé¨ Encoding MP4 video...';
            
            // Note: Full MP4 encoding requires a library or server-side processing
            // For now, we'll create a download of the frames as a ZIP
            // Full MP4 encoding can be added later with a library like FFmpeg.wasm
            
            statusDiv.innerHTML = '‚úÖ Export complete! (MP4 encoding requires FFmpeg - frames saved for now)';
            isExporting = false;
        }
        
        function finishInteractiveHTML(duration, fps, statusDiv) {
            statusDiv.innerHTML = 'üì¶ Creating interactive HTML file...';
            
            // Create standalone HTML file with timeline data
            const htmlContent = createInteractiveHTML(exportFrames, duration, fps);
            
            // Download file
            const blob = new Blob([htmlContent], {type: 'text/html'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `causation-art-${Date.now()}.html`;
            a.click();
            URL.revokeObjectURL(url);
            
            statusDiv.innerHTML = '‚úÖ Interactive HTML exported! Open the downloaded file to play.';
            isExporting = false;
            exportFrames = [];
        }
        
        function createInteractiveHTML(timeline, duration, fps) {
            // Create standalone HTML with all timeline data embedded
            const timelineJson = JSON.stringify(timeline);
            const durationMin = Math.floor(duration / 60);
            const durationSec = (duration % 60).toString().padStart(2, '0');
            
            return '<!DOCTYPE html>\n' +
'<html>\n' +
'<head>\n' +
'    <title>Causation Art - Interactive Playback</title>\n' +
'    <script src="https://d3js.org/d3.v7.min.js"></' + 'script>\n' +
'    <style>\n' +
'        body { margin: 0; background: #000; overflow: hidden; }\n' +
'        #player { position: relative; width: 100vw; height: 100vh; }\n' +
'        #canvas { width: 100%; height: 100%; }\n' +
'        #controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; }\n' +
'        button { padding: 10px 20px; margin: 0 5px; background: #0aa; border: 1px solid #0ff; color: #0ff; cursor: pointer; }\n' +
'    </style>\n' +
'</head>\n' +
'<body>\n' +
'    <div id="player">\n' +
'        <canvas id="canvas"></canvas>\n' +
'        <div id="controls">\n' +
'            <button onclick="togglePlay()">‚èØ Play/Pause</button>\n' +
'            <button onclick="resetView()">‚åÇ Home</button>\n' +
'            <span id="time">0:00 / ' + durationMin + ':' + durationSec + '</span>\n' +
'            <input type="range" id="seek" min="0" max="' + (timeline.length - 1) + '" value="0" oninput="seekTo(this.value)" style="width: 300px;">\n' +
'        </div>\n' +
'    </div>\n' +
'    <' + 'script' + '>\n' +
'        const timeline = ' + timelineJson + ';\n' +
'        const fps = ' + fps + ';\n' +
'        let currentFrame = 0;\n' +
'        let isPlaying = false;\n' +
'        let animationId = null;\n' +
'        const canvas = document.getElementById(\'canvas\');\n' +
'        const ctx = canvas.getContext(\'2d\');\n' +
'        canvas.width = window.innerWidth;\n' +
'        canvas.height = window.innerHeight;\n' +
'        \n' +
'        let zoom = 0.05, panX = 0, panY = 0, rotation = 0;\n' +
'        let userInteracted = false;\n' +
'        \n' +
'        function formatTime(t) {\n' +
'            const min = Math.floor(t / 60);\n' +
'            const sec = Math.floor(t % 60);\n' +
'            return min + \':\' + sec.toString().padStart(2, \'0\');\n' +
'        }\n' +
'        \n' +
'        function render(frame) {\n' +
'            if (!timeline[frame]) return;\n' +
'            const data = timeline[frame];\n' +
'            \n' +
'            if (!userInteracted) {\n' +
'                zoom = data.camera.zoom;\n' +
'                panX = data.camera.panX;\n' +
'                panY = data.camera.panY;\n' +
'                rotation = data.camera.rotation;\n' +
'            }\n' +
'            \n' +
'            ctx.clearRect(0, 0, canvas.width, canvas.height);\n' +
'            ctx.save();\n' +
'            ctx.translate(canvas.width / 2 + panX, canvas.height / 2 + panY);\n' +
'            ctx.scale(zoom, zoom);\n' +
'            ctx.rotate(rotation * Math.PI / 180);\n' +
'            ctx.translate(-canvas.width / 2, -canvas.height / 2);\n' +
'            \n' +
'            // Render nodes and links from timeline data\n' +
'            if (data.links) {\n' +
'                data.links.forEach(link => {\n' +
'                    const src = data.nodes.find(n => n.id === link.source);\n' +
'                    const tgt = data.nodes.find(n => n.id === link.target);\n' +
'                    if (src && tgt) {\n' +
'                        ctx.beginPath();\n' +
'                        ctx.moveTo(src.x, src.y);\n' +
'                        ctx.lineTo(tgt.x, tgt.y);\n' +
'                        ctx.strokeStyle = \'rgba(0, 255, 255, 0.5)\';\n' +
'                        ctx.stroke();\n' +
'                    }\n' +
'                });\n' +
'            }\n' +
'            \n' +
'            if (data.nodes) {\n' +
'                data.nodes.forEach(node => {\n' +
'                    ctx.beginPath();\n' +
'                    ctx.arc(node.x, node.y, 5, 0, Math.PI * 2);\n' +
'                    ctx.fillStyle = \'#00ffff\';\n' +
'                    ctx.fill();\n' +
'                });\n' +
'            }\n' +
'            \n' +
'            ctx.restore();\n' +
'            document.getElementById(\'time\').textContent = formatTime(data.t);\n' +
'            document.getElementById(\'seek\').value = frame;\n' +
'        }\n' +
'        \n' +
'        function togglePlay() {\n' +
'            isPlaying = !isPlaying;\n' +
'            if (isPlaying) {\n' +
'                animationId = setInterval(() => {\n' +
'                    currentFrame = (currentFrame + 1) % timeline.length;\n' +
'                    render(currentFrame);\n' +
'                }, 1000 / fps);\n' +
'            } else {\n' +
'                clearInterval(animationId);\n' +
'            }\n' +
'        }\n' +
'        \n' +
'        function seekTo(frame) {\n' +
'            currentFrame = parseInt(frame);\n' +
'            render(currentFrame);\n' +
'        }\n' +
'        \n' +
'        function resetView() {\n' +
'            zoom = 0.05;\n' +
'            panX = panY = rotation = 0;\n' +
'            userInteracted = false;\n' +
'            render(currentFrame);\n' +
'        }\n' +
'        \n' +
'        render(0);\n' +
'    </' + 'script>\n' +
'</body>\n' +
'</html>';
        }
        
        // Live mode functions
        function toggleLiveMode() {
            liveMode = document.getElementById('liveModeToggle').checked;
            const statusDiv = document.getElementById('liveStatus');
            
            if (liveMode) {
                statusDiv.innerHTML = '<span style="color: #0f0;">‚óè LIVE</span> <span style="color: #0aa; font-size: 0.85em;">(Updating...)</span>';
                statusDiv.style.color = '#0f0';
                startLiveMode();
            } else {
                statusDiv.innerHTML = '‚óè Historical Mode';
                statusDiv.style.color = '#0aa';
                stopLiveMode();
            }
        }
        
        function startLiveMode() {
            // Check live status every 2 seconds
            if (liveModeInterval) clearInterval(liveModeInterval);
            liveModeInterval = setInterval(checkLiveStatus, 2000);
            
            // Initial check
            checkLiveStatus();
        }
        
        function stopLiveMode() {
            if (liveModeInterval) {
                clearInterval(liveModeInterval);
                liveModeInterval = null;
            }
        }
        
        function checkLiveStatus() {
            return fetch('/api/live/status')
                .then(response => response.json())
                .then(data => {
                    const statusDiv = document.getElementById('liveStatus');
                    
                    if (data.live) {
                        statusDiv.innerHTML = `<span style="color: #0f0;">‚óè LIVE</span> <span style="color: #0aa; font-size: 0.85em;">(${data.event_count} events)</span>`;
                        
                        // Check for new events if live mode is enabled
                        if (liveMode) {
                            fetchNewEvents();
                        }
                    } else {
                        statusDiv.innerHTML = '‚óè Historical Mode';
                        statusDiv.style.color = '#0aa';
                    }
                    
                    return data; // Return data for promise chaining
                })
                .catch(err => {
                    console.error('Error checking live status:', err);
                    return {live: false}; // Return default on error
                });
        }
        
        function fetchNewEvents() {
            fetch(`/api/live/events?since=${lastEventTimestamp}`)
                .then(response => response.json())
                .then(data => {
                    if (data.events && data.events.length > 0) {
                        // New events available - reload graph
                        lastEventTimestamp = data.latest_timestamp || lastEventTimestamp;
                        
                        // Reload graph with new events
                        loadGraph();
                        
                        // Also update stats
                        updateStats();
                    }
                })
                .catch(err => {
                    console.error('Error fetching new events:', err);
                });
        }
        
        function updateStats() {
            fetch('/api/stats')
                .then(response => response.json())
                .then(stats => {
                    // Could update a stats display here
                    console.log(`Live: ${stats.total_events} events, ${stats.total_links} links`);
                })
                .catch(err => console.error('Error updating stats:', err));
        }
        
        // ============================================================================
        // CONVERGENCE RESEARCH ASSISTANT (CRA) - CHAT INTERFACE
        // ============================================================================
        
        // View state tracker
        let viewState = {
            zoom: zoomLevel,
            panX: panX,
            panY: panY,
            rotation: rotation,
            selectedNode: null,
            visibleNodes: []
        };
        
        // Chat state
        let chatHistory = [];
        let availableModels = { text: [], vision: [] };
        
        // Update view state when graph changes
        function updateViewState() {
            if (!viewState) viewState = {};
            
            viewState.zoom = zoomLevel;
            viewState.panX = panX;
            viewState.panY = panY;
            viewState.rotation = rotation;
            viewState.selectedNode = selectedNode ? selectedNode.id : null;
            
            // Get visible nodes in viewport (all nodes for now, can be filtered by viewport bounds)
            if (allNodes && allNodes.length > 0) {
                viewState.visibleNodes = allNodes.slice(0, 50).map(node => node.id); // Limit to first 50 for performance
                viewState.totalNodes = allNodes.length;
                viewState.totalLinks = allLinks ? allLinks.length : 0;
            } else {
                viewState.visibleNodes = [];
                viewState.totalNodes = 0;
                viewState.totalLinks = 0;
            }
        }
        
        // Capture graph as image (SVG to canvas to base64)
        function captureGraphImage() {
            return new Promise((resolve) => {
                if (!svg || !svg.node()) {
                    resolve(null);
                    return;
                }
                
                try {
                    // Create a clone of the SVG that respects visibility filters
                    const svgElement = svg.node();
                    const clone = svgElement.cloneNode(true);
                    
                    // Get computed styles for visibility checking
                    const style = window.getComputedStyle(svgElement);
                    
                    // Remove hidden links from clone
                    const originalLinks = svgElement.querySelectorAll('.link');
                    const cloneLinks = clone.querySelectorAll('.link');
                    originalLinks.forEach((origLink, idx) => {
                        const origStyle = window.getComputedStyle(origLink);
                        if (origStyle.display === 'none' || origStyle.visibility === 'hidden' || origStyle.opacity === '0') {
                            if (cloneLinks[idx]) {
                                cloneLinks[idx].remove();
                            }
                        }
                    });
                    
                    // Remove hidden text labels from clone
                    const originalTexts = svgElement.querySelectorAll('.node text');
                    const cloneTexts = clone.querySelectorAll('.node text');
                    originalTexts.forEach((origText, idx) => {
                        const origStyle = window.getComputedStyle(origText);
                        if (origStyle.display === 'none' || origStyle.visibility === 'hidden' || origStyle.opacity === '0') {
                            if (cloneTexts[idx]) {
                                cloneTexts[idx].remove();
                            }
                        }
                    });
                    
                    // Remove hidden nodes from clone (entire node groups)
                    const originalNodes = svgElement.querySelectorAll('.node');
                    const cloneNodes = clone.querySelectorAll('.node');
                    originalNodes.forEach((origNode, idx) => {
                        const origStyle = window.getComputedStyle(origNode);
                        if (origStyle.display === 'none' || origStyle.visibility === 'hidden' || origStyle.opacity === '0') {
                            if (cloneNodes[idx]) {
                                cloneNodes[idx].remove();
                            }
                        }
                    });
                    
                    // Serialize the filtered clone
                    const svgData = new XMLSerializer().serializeToString(clone);
                    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(svgBlob);
                    
                    // Create image from SVG
                    const img = new Image();
                    img.onload = function() {
                        // Aggressively resize for Ollama Cloud (smaller max size)
                        // Start with smaller dimensions to ensure we stay under limits
                        const maxWidth = 800;  // Reduced from 1200
                        const maxHeight = 600; // Reduced from 800
                        let canvasWidth = svgElement.clientWidth || 800;
                        let canvasHeight = svgElement.clientHeight || 600;
                        
                        // Scale down if too large
                        const scale = Math.min(1, maxWidth / canvasWidth, maxHeight / canvasHeight);
                        if (scale < 1) {
                            canvasWidth = Math.floor(canvasWidth * scale);
                            canvasHeight = Math.floor(canvasHeight * scale);
                        }
                        
                        // Create canvas with compressed size
                        const canvas = document.createElement('canvas');
                        canvas.width = canvasWidth;
                        canvas.height = canvasHeight;
                        const ctx = canvas.getContext('2d');
                        
                        // Use image smoothing for better quality at smaller size
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'medium'; // Lower quality for smaller size
                        
                        // Draw image to canvas
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        
                        // Aggressively compress: start with lower quality (75%)
                        // Target max size: 800KB base64 (‚âà600KB binary)
                        // Ollama Cloud seems to have strict limits on base64 size
                        const TARGET_SIZE = 800000; // 800KB base64 string
                        let base64 = canvas.toDataURL('image/jpeg', 0.75);
                        
                        // Progressive compression loop until we're under target
                        let quality = 0.75;
                        while (base64.length > TARGET_SIZE && quality > 0.3) {
                            quality -= 0.1; // Reduce quality by 10%
                            base64 = canvas.toDataURL('image/jpeg', quality);
                            
                            // If still too large, resize the canvas itself
                            if (base64.length > TARGET_SIZE && canvasWidth > 400) {
                                const resizeFactor = Math.sqrt(TARGET_SIZE / base64.length) * 0.95; // 95% to be safe
                                const newWidth = Math.max(400, Math.floor(canvasWidth * resizeFactor));
                                const newHeight = Math.max(300, Math.floor(canvasHeight * resizeFactor));
                                
                                const resizedCanvas = document.createElement('canvas');
                                resizedCanvas.width = newWidth;
                                resizedCanvas.height = newHeight;
                                const resizedCtx = resizedCanvas.getContext('2d');
                                resizedCtx.imageSmoothingEnabled = true;
                                resizedCtx.imageSmoothingQuality = 'medium';
                                resizedCtx.fillStyle = '#000000';
                                resizedCtx.fillRect(0, 0, resizedCanvas.width, resizedCanvas.height);
                                resizedCtx.drawImage(canvas, 0, 0, newWidth, newHeight);
                                
                                canvasWidth = newWidth;
                                canvasHeight = newHeight;
                                canvas.width = newWidth;
                                canvas.height = newHeight;
                                const newCtx = canvas.getContext('2d');
                                newCtx.drawImage(resizedCanvas, 0, 0);
                                
                                base64 = canvas.toDataURL('image/jpeg', quality);
                            }
                        }
                        
                        // Final check: if still too large, reject it
                        if (base64.length > TARGET_SIZE * 1.2) { // Allow 20% over target
                            console.warn(`Image still too large after compression: ${(base64.length / 1024).toFixed(1)}KB (target: ${(TARGET_SIZE / 1024).toFixed(1)}KB)`);
                            // Return smaller placeholder or null - backend will handle the error
                            resolve(null);
                            return;
                        }
                        
                        console.log(`Image compressed: ${(base64.length / 1024).toFixed(1)}KB (${canvasWidth}x${canvasHeight}, quality: ${quality.toFixed(2)})`);
                        URL.revokeObjectURL(url);
                        resolve(base64);
                    };
                    img.onerror = () => resolve(null);
                    img.src = url;
                } catch (error) {
                    console.error('Error capturing graph image:', error);
                    resolve(null);
                }
            });
        }
        
        // Load available Ollama models
        function loadOllamaModels() {
            fetch('/api/ollama/models')
                .then(response => response.json())
                .then(data => {
                    availableModels = {
                        text: data.text_models || [],
                        vision: data.vision_models || []
                    };
                    
                    // Populate model selectors
                    const researchSelect = document.getElementById('researchModelSelect');
                    const visionSelect = document.getElementById('visionModelSelect');
                    
                    // Clear existing options
                    researchSelect.innerHTML = '';
                    visionSelect.innerHTML = '';
                    
                    // Add text models
                    if (availableModels.text && availableModels.text.length > 0) {
                        availableModels.text.forEach(model => {
                            const modelName = typeof model === 'string' ? model : (model.name || model.model || '');
                            if (modelName) {
                                const option = document.createElement('option');
                                option.value = modelName;
                                // Mark cloud models with üåê indicator
                                const isCloud = modelName.toLowerCase().includes('-cloud') || modelName.toLowerCase().endsWith(':cloud');
                                option.textContent = isCloud ? `üåê ${modelName}` : modelName;
                                researchSelect.appendChild(option);
                            }
                        });
                        // Set first model as default if available
                        if (researchSelect.options.length > 0) {
                            researchSelect.selectedIndex = 0;
                        }
                    } else {
                        // No text models found
                        const option = document.createElement('option');
                        option.value = '';
                        option.textContent = 'No models available';
                        researchSelect.appendChild(option);
                    }
                    
                    // Add vision models
                    if (availableModels.vision && availableModels.vision.length > 0) {
                        availableModels.vision.forEach(model => {
                            const modelName = typeof model === 'string' ? model : (model.name || model.model || '');
                            if (modelName) {
                                const option = document.createElement('option');
                                option.value = modelName;
                                // Mark cloud models with üåê indicator
                                const isCloud = modelName.toLowerCase().includes('-cloud') || modelName.toLowerCase().endsWith(':cloud');
                                option.textContent = isCloud ? `üåê ${modelName}` : modelName;
                                visionSelect.appendChild(option);
                            }
                        });
                        // Set first model as default if available
                        if (visionSelect.options.length > 0) {
                            visionSelect.selectedIndex = 0;
                        }
                    } else {
                        // No vision models found - add all models as fallback
                        if (data.models && data.models.length > 0) {
                            data.models.forEach(model => {
                                const modelName = typeof model === 'string' ? model : (model.name || model.model || '');
                                if (modelName) {
                                    const option = document.createElement('option');
                                    option.value = modelName;
                                    // Mark cloud models with üåê indicator
                                    const isCloud = modelName.toLowerCase().includes('-cloud') || modelName.toLowerCase().endsWith(':cloud');
                                    option.textContent = isCloud ? `üåê ${modelName}` : modelName;
                                    visionSelect.appendChild(option);
                                }
                            });
                            if (visionSelect.options.length > 0) {
                                visionSelect.selectedIndex = 0;
                            }
                        } else {
                            const option = document.createElement('option');
                            option.value = '';
                            option.textContent = 'No vision models available';
                            visionSelect.appendChild(option);
                        }
                    }
                    
                    // Update status
                    const totalModels = (availableModels.text?.length || 0) + (availableModels.vision?.length || 0);
                    if (totalModels > 0) {
                        updateChatStatus(`Loaded ${totalModels} model(s)`);
                    } else {
                        updateChatStatus('No models found. Make sure Ollama is running and models are downloaded.');
                    }
                })
                .catch(err => {
                    console.error('Error loading Ollama models:', err);
                    const researchSelect = document.getElementById('researchModelSelect');
                    const visionSelect = document.getElementById('visionModelSelect');
                    researchSelect.innerHTML = '<option value="">Error loading models</option>';
                    visionSelect.innerHTML = '<option value="">Error loading models</option>';
                    updateChatStatus('Error loading models. Make sure Ollama is running.');
                });
        }
        
        // Send chat message
        async function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Clear input
            input.value = '';
            
            // Add user message to chat
            addChatMessage('user', message);
            
            // Update status
            updateChatStatus('Thinking...');
            
            // Update view state
            updateViewState();
            
            // Capture current graph image
            const graphImage = await captureGraphImage();
            
            // Add to snapshot history for evolutionary analysis
            if (graphImage) {
                snapshotHistory.push({
                    timestamp: Date.now(),
                    image: graphImage,
                    viewState: JSON.parse(JSON.stringify(viewState))
                });
                
                // Keep only last MAX_SNAPSHOTS snapshots
                if (snapshotHistory.length > MAX_SNAPSHOTS) {
                    snapshotHistory.shift(); // Remove oldest
                }
            }
            
            // Get selected model
            const researchModel = document.getElementById('researchModelSelect').value;
            const visionModel = document.getElementById('visionModelSelect').value;
            
            // Get selected event if any
            const selectedEvent = selectedNode ? selectedNode.id : null;
            
            // Build request with evolutionary snapshots (limit by size)
            let evolutionarySnapshots = snapshotHistory.map(s => ({
                timestamp: s.timestamp,
                image: s.image,
                age_seconds: (Date.now() - s.timestamp) / 1000
            }));
            
            // Calculate total payload size and trim if needed
            let totalSize = JSON.stringify({
                message: message,
                evolutionary_snapshots: evolutionarySnapshots,
                graph_image: graphImage || ''
            }).length;
            
            // If payload too large, reduce snapshots (keep most recent)
            if (totalSize > MAX_PAYLOAD_SIZE && evolutionarySnapshots.length > 1) {
                // Start with most recent and work backwards
                const trimmed = [];
                let currentSize = JSON.stringify({message: message, graph_image: graphImage || ''}).length;
                
                for (let i = evolutionarySnapshots.length - 1; i >= 0; i--) {
                    const testSize = currentSize + JSON.stringify(evolutionarySnapshots[i]).length;
                    if (testSize < MAX_PAYLOAD_SIZE * 0.9) { // Use 90% of limit for safety
                        trimmed.unshift(evolutionarySnapshots[i]);
                        currentSize = testSize;
                    } else {
                        break; // Stop adding if would exceed limit
                    }
                }
                
                evolutionarySnapshots = trimmed;
                console.log(`Trimmed snapshots from ${snapshotHistory.length} to ${trimmed.length} to fit payload size`);
            }
            
            const requestData = {
                message: message,
                model: researchModel,
                vision_model: visionModel,
                view_state: viewState,
                selected_event: selectedEvent,
                graph_image: graphImage,
                evolutionary_snapshots: evolutionarySnapshots
            };
            
            // Send to backend
            fetch('/api/ollama/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestData)
            })
            .then(response => response.json())
            .then(data => {
                updateChatStatus('');
                
                if (data.error) {
                    addChatMessage('assistant', `Error: ${data.error}`, true);
                    return;
                }
                
                // Show vision description if available
                if (data.visual_description) {
                    addChatMessage('vision', `[Vision Analysis] ${data.visual_description}`);
                } else if (data.vision_error) {
                    // Show vision error if vision model was selected but failed
                    addChatMessage('vision', `‚ö†Ô∏è Vision Model Error: ${data.vision_error}`, true);
                }
                
                // Show assistant response
                if (data.response) {
                    addChatMessage('assistant', data.response);
                } else {
                    addChatMessage('assistant', 'No response received.');
                }
                
                // Show context sources
                if (data.context_sources) {
                    const sources = data.context_sources;
                    const sourceInfo = `[Context: ${sources.graph_events} events, ${sources.log_files} log files]`;
                    updateChatStatus(sourceInfo);
                }
            })
            .catch(err => {
                console.error('Error sending chat message:', err);
                updateChatStatus('Error sending message.');
                addChatMessage('assistant', `Error: ${err.message}`, true);
            });
        }
        
        // Simple markdown renderer for chat messages
        function renderMarkdown(text) {
            if (!text) return '';
            
            // Escape HTML first to prevent XSS, then apply markdown
            let html = escapeHtml(text);
            
            // Headers
            html = html.replace(/^### (.*$)/gim, '<h3 style="color: #0ff; margin: 10px 0 5px 0; font-size: 1.1em;">$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2 style="color: #0ff; margin: 12px 0 8px 0; font-size: 1.2em; border-bottom: 1px solid #0aa;">$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h1 style="color: #0ff; margin: 15px 0 10px 0; font-size: 1.4em; border-bottom: 2px solid #0ff;">$1</h1>');
            
            // Bold (**text** or __text__)
            html = html.replace(/\*\*([^*]+)\*\*/g, '<strong style="color: #fff; font-weight: bold;">$1</strong>');
            html = html.replace(/__([^_]+)__/g, '<strong style="color: #fff; font-weight: bold;">$1</strong>');
            
            // Italic (*text* or _text_)
            html = html.replace(/\*([^*]+)\*/g, '<em style="color: #0aa;">$1</em>');
            html = html.replace(/_([^_]+)_/g, '<em style="color: #0aa;">$1</em>');
            
            // Code blocks (```code```)
            html = html.replace(/```([^`]+)```/g, '<pre style="background: #0a0a0a; border: 1px solid #0aa; padding: 8px; margin: 8px 0; color: #0ff; overflow-x: auto; font-size: 0.9em; border-radius: 4px;"><code>$1</code></pre>');
            
            // Inline code (`code`)
            html = html.replace(/`([^`]+)`/g, '<code style="background: #0a0a0a; border: 1px solid #0aa; padding: 2px 4px; color: #0ff; font-family: monospace; border-radius: 3px;">$1</code>');
            
            // Lists (- item or * item)
            html = html.replace(/^[-*] (.*$)/gim, '<li style="margin: 4px 0; margin-left: 20px; color: #0f0;">$1</li>');
            html = html.replace(/^(\d+)\. (.*$)/gim, '<li style="margin: 4px 0; margin-left: 20px; color: #0f0;">$2</li>');
            // Wrap consecutive list items in <ul>
            html = html.replace(/(<li[^>]*>.*?<\/li>\n?)+/g, function(match) {
                return '<ul style="margin: 8px 0; padding-left: 20px;">' + match + '</ul>';
            });
            
            // Horizontal rules
            html = html.replace(/^---$/gim, '<hr style="border: none; border-top: 1px solid #0aa; margin: 10px 0;">');
            
            // Process line breaks - split into paragraphs by double newlines
            const paragraphs = html.split(/\n\n+/);
            const processedParagraphs = paragraphs.map(p => {
                if (!p.trim()) return '<br>';
                
                // Convert single newlines within paragraphs to <br>
                p = p.replace(/\n/g, '<br>');
                
                // If already has HTML tags (headers, lists, etc.), don't wrap in <p>
                if (p.trim().match(/^<(h[1-6]|ul|li|pre|hr|p)/)) {
                    return p;
                }
                
                return `<p style="margin: 8px 0; line-height: 1.6;">${p}</p>`;
            });
            
            return processedParagraphs.join('');
        }
        
        // Add message to chat
        function addChatMessage(role, message, isError = false) {
            const messagesDiv = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${role}`;
            
            const roleLabel = role === 'user' ? 'You' : role === 'assistant' ? 'CRA' : 'Vision';
            const color = isError ? '#f00' : role === 'user' ? '#0f0' : role === 'assistant' ? '#0ff' : '#ff0';
            
            // Render markdown for assistant and vision messages, plain text for user
            const messageContent = (role === 'assistant' || role === 'vision') ? renderMarkdown(message) : escapeHtml(message);
            
            messageDiv.innerHTML = `<strong style="color: ${color}; display: block; margin-bottom: 8px; font-size: 1.05em;">${roleLabel}:</strong><div style="line-height: 1.6; word-wrap: break-word;">${messageContent}</div>`;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        // Update chat status
        function updateChatStatus(status) {
            document.getElementById('chatStatus').textContent = status;
        }
        
        // Load Ollama configuration on page load
        function loadOllamaConfig() {
            fetch('/api/ollama/config')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Set cloud mode checkbox
                    const cloudModeCheckbox = document.getElementById('ollamaCloudMode');
                    const cloudSettings = document.getElementById('cloudSettings');
                    
                    if (data.is_cloud) {
                        cloudModeCheckbox.checked = true;
                        cloudSettings.style.display = 'block';
                        // Don't show API key for security (but show if it's set)
                        if (data.has_api_key) {
                            document.getElementById('ollamaApiKey').value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢'; // Masked
                        }
                    } else {
                        cloudModeCheckbox.checked = false;
                        cloudSettings.style.display = 'none';
                    }
                    
                    updateOllamaConnectionStatus();
                })
                .catch(err => {
                    console.error('Error loading Ollama config:', err);
                    updateOllamaConnectionStatus('Error loading config');
                });
        }
        
        // Toggle cloud mode
        function toggleCloudMode() {
            const cloudModeCheckbox = document.getElementById('ollamaCloudMode');
            const cloudSettings = document.getElementById('cloudSettings');
            
            if (cloudModeCheckbox.checked) {
                cloudSettings.style.display = 'block';
            } else {
                cloudSettings.style.display = 'none';
                // Switch back to local
                saveOllamaConfig(false);
            }
        }
        
        // Save Ollama configuration
        function saveOllamaConfig(useCloud = null) {
            const cloudModeCheckbox = document.getElementById('ollamaCloudMode');
            const apiKeyInput = document.getElementById('ollamaApiKey');
            const statusDiv = document.getElementById('configStatus');
            
            // Determine if we should use cloud
            if (useCloud === null) {
                useCloud = cloudModeCheckbox.checked;
            }
            
            const config = {
                base_url: useCloud ? 'https://ollama.com' : 'http://localhost:11434',
                timeout: 60
            };
            
            // Only include API key if using cloud mode
            if (useCloud) {
                const apiKey = apiKeyInput.value;
                if (!apiKey || apiKey === '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢') {
                    // If masked, don't send (keep existing)
                    statusDiv.innerHTML = '<span style="color: #f00;">Please enter your API key!</span>';
                    return;
                }
                config.api_key = apiKey;
            }
            
            statusDiv.innerHTML = '<span style="color: #0aa;">Saving...</span>';
            
            fetch('/api/ollama/config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(config)
            })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        try {
                            const json = JSON.parse(text);
                            throw new Error(json.error || `HTTP ${response.status}`);
                        } catch (e) {
                            if (e instanceof Error && e.message.includes('HTTP')) {
                                throw e;
                            }
                            throw new Error(`HTTP ${response.status}: ${text.substring(0, 100)}`);
                        }
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    statusDiv.innerHTML = '<span style="color: #0f0;">‚úÖ Saved! Reloading models...</span>';
                    // Reload models after config change (cloud models will be different)
                    loadOllamaModels();
                    // Test connection
                    testOllamaConnection();
                    // Mask the API key in the input
                    if (useCloud && apiKeyInput.value) {
                        apiKeyInput.type = 'password';
                        apiKeyInput.value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                    }
                } else {
                    statusDiv.innerHTML = `<span style="color: #f00;">‚ùå Error: ${data.error || 'Unknown error'}</span>`;
                }
            })
            .catch(err => {
                console.error('Error saving Ollama config:', err);
                statusDiv.innerHTML = `<span style="color: #f00;">‚ùå Error: ${err.message || 'Failed to save configuration'}</span>`;
            });
        }
        
        // Test Ollama connection
        function testOllamaConnection() {
            const statusDiv = document.getElementById('ollamaConnectionStatus');
            statusDiv.innerHTML = '<span style="color: #0aa;">Testing connection...</span>';
            
            fetch('/api/ollama/test', {
                method: 'POST'
            })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        try {
                            const json = JSON.parse(text);
                            throw new Error(json.error || `HTTP ${response.status}`);
                        } catch (e) {
                            if (e instanceof Error && e.message.includes('HTTP')) {
                                throw e;
                            }
                            throw new Error(`HTTP ${response.status}`);
                        }
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.success && data.connected) {
                    statusDiv.innerHTML = `<span style="color: #0f0;">‚úÖ Connected (${data.mode} mode, ${data.model_count} models)</span>`;
                } else {
                    statusDiv.innerHTML = `<span style="color: #f00;">‚ùå Connection failed: ${data.error || 'Unknown error'}</span>`;
                }
            })
            .catch(err => {
                console.error('Error testing Ollama connection:', err);
                statusDiv.innerHTML = `<span style="color: #f00;">‚ùå Connection error: ${err.message || 'Failed to connect'}</span>`;
            });
        }
        
        // Update connection status
        function updateOllamaConnectionStatus(message = null) {
            if (message) {
                document.getElementById('ollamaConnectionStatus').innerHTML = `<span style="color: #f00;">${message}</span>`;
                return;
            }
            testOllamaConnection();
        }
        
        // Copy all chat messages to clipboard
        function copyAllChat() {
            const messagesDiv = document.getElementById('chatMessages');
            if (!messagesDiv) return;
            
            const messages = messagesDiv.querySelectorAll('.chat-message, div');
            let chatText = '';
            
            messages.forEach(msg => {
                const text = msg.textContent || msg.innerText;
                if (text.trim()) {
                    chatText += text.trim() + '\n\n';
                }
            });
            
            // Copy to clipboard
            navigator.clipboard.writeText(chatText).then(() => {
                // Show feedback
                const buttons = document.querySelectorAll('button[onclick="copyAllChat()"]');
                buttons.forEach(button => {
                    const originalText = button.textContent;
                    button.textContent = '‚úì Copied!';
                    button.style.background = '#0f0';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.background = '#0aa';
                    }, 2000);
                });
            }).catch(err => {
                console.error('Failed to copy chat:', err);
                alert('Failed to copy chat. Please select and copy manually.');
            });
        }
        
        // Export analysis report
        function exportAnalysis() {
            const messagesDiv = document.getElementById('chatMessages');
            if (!messagesDiv) return;
            
            // Collect all chat messages
            const messages = messagesDiv.querySelectorAll('.chat-message, div');
            let report = '# Butterfly System - CRA Analysis Report\n';
            report += `Generated: ${new Date().toISOString()}\n`;
            report += '='.repeat(60) + '\n\n';
            
            // Add system context header
            report += '## Chat History\n\n';
            
            // Add messages
            messages.forEach(msg => {
                const text = msg.textContent || msg.innerText;
                if (text.trim()) {
                    // Format messages nicely
                    const roleMatch = text.match(/^(You|CRA|Vision):\s*(.*)$/);
                    if (roleMatch) {
                        const role = roleMatch[1];
                        const content = roleMatch[2];
                        report += `### ${role}\n\n${content}\n\n`;
                    } else {
                        report += `${text.trim()}\n\n`;
                    }
                }
            });
            
            // Add metadata
            report += '\n---\n\n';
            report += '## Metadata\n\n';
            report += `- Total Messages: ${messages.length}\n`;
            report += `- Graph Nodes: ${allNodes.length}\n`;
            report += `- Graph Links: ${allLinks.length}\n`;
            report += `- Zoom Level: ${Math.round(zoomLevel * 100)}%\n`;
            
            // Create download
            const blob = new Blob([report], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            a.href = url;
            a.download = `causation_analysis_${timestamp}.md`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Show feedback
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = '‚úì Saved!';
            button.style.background = '#0f0';
            setTimeout(() => {
                button.textContent = originalText;
                button.style.background = '#0aa';
            }, 2000);
        }
        
        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Load models on page load
        loadOllamaModels();
        
        // Call updateViewState periodically to track changes
        setInterval(updateViewState, 500); // Update every 500ms
        
        // Load graph on page load
        loadGraph();
        
        // Load Ollama configuration on page load
        loadOllamaConfig();
        
        // Check initial live status and auto-enable live mode if system is running
        checkLiveStatus().then(data => {
            if (data && data.live) {
                // System is live - automatically enable live mode
                document.getElementById('liveModeToggle').checked = true;
                toggleLiveMode();
            }
        });
    </script>
</body>
</html>

